[ { "title": "Li Jian's Song List from My girlfriend", "url": "/posts/Lijian-song-list/", "categories": "Song", "tags": "Lijian", "date": "2022-11-27 00:00:00 +0000", "snippet": " 父亲写的散文诗 水流众生 月光 雨后初晴 今天是你的生日 妈妈 消失的月光 一念一生 老情歌 在水一方 一切刚刚好 君子行 车站 美若黎明 深海之寻 袖手旁观 向往 绽放 城市之光 众妙 Feeling Good 璀璨 门 无烟之火 紫罗兰 幻梦花园 人群中的人 美丽生灵 我唯有的你 梅雨 风花树 雨夜曲 珍爱深深 依然在路上 抚仙湖 深町小夜曲 日落之前 雾中列车 当有天老去 沧海轻舟 我愿人长久 万物安生 故乡山川" }, { "title": "Notes for Bioinfomatics Data Skills", "url": "/posts/Buffalo-bioinformaticsDS-learning/", "categories": "", "tags": "LearningNotes", "date": "2022-08-10 00:00:00 +0000", "snippet": "1. How to learn bioinformatics Assert about assumptions: Python’s assert() and R’s stopifnot() Develop frequently used scripts into tools2. Setting up and managing a bioinformatics project Create a well-organized directory structure Document your project in detail: command lines, data source, tool version3. Remedial unix shell Use tail -f to monitor redirected standard error Use tee to store standard output stream to an intermediate file Use fg %&lt;job id&gt; to return program to foreground Use bg %&lt;job id&gt; to put a suspended job into background and run Use operator &amp;&amp; to chain two commands in which the later one is dependent on the first one Command substitution, use mkdir reuslts-$(date +%F) to create a directory with current date as name4. Working with remote machines5. Git6. Bioinformatics data Use powerful wget --accept --recursive --no-parent --limit-rate -O Use curl -O to download redirected content Use rsync -avz -e ssh source destination to transfer entire directory to remote machine, archive, compressed Use diff -u file1 file2 to find differnece between two small files Use gunzip -c file.txt.gz &gt; file.txt to keep original compressed file Use zgrep, zcat, zless The most important step in documenting your work is that you’re consistent and make it a habit.7. Unix data tools (head -n 2; tail -n 2) Keep in mind wc -l is not robust in some cases Use column -t to neat output, default delimiter is \\t, can be changed by -s -E turn on grep’s extended regular expression, aliasd to egrep Deal with Non-ASCII files, alias nonascii=\"LC_CTYPE=C grep --color='auto' -n -P '[\\x80-\\xFF]'\" sort -s makes sort stable (turns off last-resort sorting) sort -c check sorting status sort -k1,1V understands numbers inside strings uniq -d outputs duplicated lines Use join -1 column1 -2 column2 (-a 1) file1 file2 to join two files by specific column awk -F\",\" -v OFS=\"\\t\" {} associative array in awk works like dictionaries in Python bioawk -c hdr is powerful for processing long-column with header files sed for capturing text between delimiters Use subshell to combine two sequential commands’ standard output into a single stream. Like(zgrep \"^#\" gtf.gz; zgrep -v \"^#\" gtf.gz | sort -Vk1,1 -k4,4n) | gzip &gt; sorted.gtf.gz mkfifo namedpipe to create a named pipe object Process substitution, input to the program &lt;(...), output to the program &gt;(...) like &gt;(gzip &gt; file.txt.gz8. Introducing R factor is class, its type is integer Set colClasses to NULL can force R to skip the column Set nrow to include several number of rows of a file when using read.delim() read.delim() read string column as factors by default, disable it by set stringAsFactors=F comment.char ignore lines begin with this argument na.strings=c('na', 'Na', 'NA') set all these values to NA Set drop=F when subsetting one column from a dataframe and keep it a dataframe which.min(), which.max() subset(data, conditions) scale_x_log10(), scale_x_continuous(limits=c(start, end)) transparency level alpha Cleveland’s Visualizing Data binning data, cut() by breaks (how many groups) or by pre-specified ranges single column: geom_density() - continuous, and geom_bar() - discrete match(x, y) returns the first occurrence of each of x’s values in y merge two datasets is comman task in data analysis, use match() or merge() visualize by categories: facet_wrap(), facet_grid(), like table() for summarizing data data structure, data types (integer, double, character, logical, complex, and raw) and class (numeric, factor) are different str() refers to structure9. Working with Range data10. Working with Sequence data11. Working with alignment data12. Shell scripting, pipelines and parallelizing tasks13. Out-of-memory approaches: Tabix and SQLite" }, { "title": "ComplexHeatmap LearingNotes", "url": "/posts/ComplexHeatmap-learning/", "categories": "R, heatmap", "tags": "LearningNotes", "date": "2022-07-18 00:00:00 +0000", "snippet": "Tutorial websitesWhen drawing a heatmap, I think following points are important: assign beautiful colors in regard to numerical variables and categorical variables 1.1 integer number or float number -&gt; discrete color or continuous color clustering 2.1 self-defined clustering method 2.2 beautiful dendrograms 2.3 reorder row or column 2.4 relabel row or column names heatmap split add row and column annotations, annotation name, bar size, position, text annotations legend positions split cells, add context in cellsAssign colors# this is for continuous valuescirclize::colorRamp2(breaks, colors)# for discrete case, directly assign colors to different categories, a named vectorsClustering# self-defined clustering method, a function that accept two argumentsrobust_dist = function(x, y){}Heatmap(test1, clustering_distance_rows = robust_dist)Comparison between different distancing methodsEuclideanPearsonSpearmanKendallComparison between different clustering methodsward.Dward.D2singlecompleteaveragemediancentroidComparison between different partition methodsk-meanspam" }, { "title": "pysam basic usage", "url": "/posts/pysam-learning/", "categories": "", "tags": "", "date": "2022-07-05 00:00:00 +0000", "snippet": "Original sourceSeveral useful usagesimport pysam# open a BAM filesamfile = pysam.AlignmentFile('file.bam', 'rb')# fetch reads mapped to a regionfor x in samfile.fetch('chr1', 10, 20):\tprint(str(x))# pileup - single basecount in the regionfor x in samfile.pileup('chr1', 10, 20):\tprint(str(x))# use samtools commands with pythonpysam.sort('-o', 'output.bam', 'in.bam')# which is same as `samtools sort -o output.bam in.bam`# work with tabix file, like bgzip compressed and tabix indexed gtf filetabixFile = pysam.TabixFile('in.gtf.gz')for gtf in tabixFile.fetch(reference='1', start=100000, end=110000, parser=pysam.asGTF()): print(gtf.contig, gtf.start, gtf.end, gtf.gene_id)# work with VCF/BCFfrom pysam import VariantFilebcfFile = VariantFile('in.bcf')for x in bcfFile.fetch('chr1', 1000, 2000):\tprint(x.contig, x.pos, x.ref)" }, { "title": "Learn Git", "url": "/posts/Git-learning/", "categories": "Git", "tags": "", "date": "2022-06-21 00:00:00 +0000", "snippet": "绑定本地仓库到GitHubgit config --global user.name \"Your Name\"git config --global user.email \"email@example.com\"初始化git仓库git init# 也可以直接clone一个已经创建的远程仓库到本地git clone git@github.com:sunjh22/CNVPipe.git# clone privite仓库可以用下面的方法# 先去 Settings -&gt; Developer settings -&gt; Personal access tokens 创建一个新token# 然后复制下面的内容，输入用户名和token即可git clone https://github.com/sunjh22/CNVPipe.git# 这样操作不便之处在于每次远程推送都需要输入用户名和token基本操作# 添加文件git add file.txt# 提交文件git commit -m 'message'# 添加远程仓库，origin可以改为任意的名字，会绑定后面的地址git remote add origin git@github.com:sunjh22/CNVPipe.git# 删除远程库链接git remote rm origin# 从本地仓库推送到远程仓库git push origin main# 先指定本地dev分支与远程origin/dev分支的链接git branch --set-upstream-to=origin/dev dev# 再抓取最新的远程库git pull# 查看工作区状态git status# 查看修改内容git diff file.txt# 查看历史版本git log --pretty=oneline --graph# 回退到之前版本git reset --hard commit_id# 回到上一个版本git reset --hard HEAD^# 撤销工作区的修改git checkout -- file.txt# 撤下暂存区的修改git reset HEAD file.txt# 删除版本库中的文件git rm file.txt# 查看远程库的信息git remote -v分支的概念# 创建分支git branch branchname# 切换分支git switch branchname# 创建+切换git switch -c branchname# 查看当前分支git branch# 在本地创建和远程分支对应的分支git branch -b dev origin/dev# 合并指定分支到当前分支git merge branchname# 删除某一分支git branch -d branchname# 手动解决合并中的冲突# 保存当前工作现场git stash# 恢复工作现场git stash pop# 复制一个特定的提交(commit)到当前分支git cherry-pick &lt;commit_id&gt;标签# 打标签，默认是给HEAD打标签，也可以指定特定commit-idgit tag &lt;tagname&gt;# 加标签信息git tag -a &lt;tagname&gt; -m '标签信息'# 查看标签git tag# 删除本地标签git tag -d tagname# 推送特定标签到远程git push origin tagname# 推送全部本地标签到远程git push origin --tags# 删除远程标签git push origin :refs/tags/&lt;tagname&gt;.gitignore# 可以用通用字符排除文件，可以用!字符另外加入例外文件generate keyssh-keygen -t rsa -C 'xxxxx@company.com' -f ~/.ssh/gitee_id_rsa基本概念 工作区 &lt;-&gt; 暂存区 &lt;-&gt; 当前分支远程仓库的设置 创建ssh key ssh-keygen -t rsa -C \"youremail@example.com\" 登陆GitHub，打开“Account settings”，“SSH Keys”页面，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容" }, { "title": "Bioinformatics", "url": "/posts/Bioinformatics/", "categories": "", "tags": "", "date": "2022-06-13 00:00:00 +0000", "snippet": "SortSort a bed file according to chromosome and start position$ sort -Vk 1 -k 2,3n demo.bedCommCompare two files, show comman lines$ comm -12 file1 file2uppercase to lowercaseA good referenceConverting all letters$ echo \"Hello There\" | tr [:lower:] [:upper:]$ echo \"Hello There\" | tr a-z A-Z$ echo \"Hello There\" | awk '{print toupper($0)}'$ echo $dept | sed 's/[a-z]/\\U&amp;/g'Capitalizing first letters only$ echo design \\&amp; engineering| sed -e \"s/\\b\\(.\\)/\\u\\1/g\"Making sure only first letters are uppercase$ echo -n \"design &amp; engineering\" | python3 -c \"import sys; print(sys.stdin.read().title())\"在网页上查看IGV的结果全部运行在10.20.57.27服务器上下载node.js二进制版本wget https://nodejs.org/dist/v16.15.1/node-v16.15.1-linux-x64.tar.xztar -xf https://nodejs.org/dist/v16.15.1/node-v16.15.1-linux-x64.tar.xz软链接npm,npx,node到~/data3/bin/，然后在tmux中开启一个服务器tmux new -s webnpx http-server ./ -p 10086用igv_web.py生成一个index.html。主要是借用igv.js在browser上直接展示IGV的结果python ~/data3/bin/igv_web.py -r /data3/refs/hg38/analysisSet/hg38.analysisSet.fa -m level1_node0_cell0.bam -g /data3/refs/hg38/annotation/UCSC.hg38.ncbiRefSeq.gtf要注意10086这个端口必须已经开放，需要root或sudo权限sudo iptables -I INPUT -p tcp --dport 10086 -j ACCEPT然后在10.20.57.27:10086上就可以访问IGV的展示结果了Mean-shift algorithm参考这篇文章t-test one-sample t-test: 比较一组样本(数量为n)的均值与一个预期的总体均值是否相等，null hypothesis就是相等，自由度为n-1 two-sample t-test: 比较两组样本(数量分别为n1,n2)的均值是否相等，null hypothesis是相等，自由度为n1+n2-2，假设是两个样本都服从正态分布且方差相同 Welch-test: 和two-sample t-test一样，都是比较两组样本的均值是否相等，但是没有两组样本方差相同的假设center, scale and normalize 中心化(center): 使样本的均值减去一个特定的值(通常为减到0或减去样本的中位数值) 标准化(scale): 使样本的均值为0，标准差为1，也即正态化。在单细胞中一般对基因做scale，目的是更好的在热图上展示不同基因在细胞中的表达差异 归一化(normalize): 使样本的值落在0-1之间(通过min-max normalization: x’ = (x - X_min) / (X_max - X_min))，或-1到1之间(通过x’ = (x - μ) / (X_max - X_min))remove duplicatessamtools rmdup: 比较适合单端reads去重，只考虑reads map的起始和终止位置，方向还有质量值，不考虑比对情况，结果会直接去除重复的readsgatk RemoveDuplicatesSpark: 适合双端reads去重，考虑reads5’端比对到的位置，方向和碱基比对情况，结果只会标记重复的reads而不会去除bwa mem -Msupplementary reads指的是一条reads中的一部分map到参考区域一，另一部分map到参考区域二，较短的一部分的flag值是2048；secondary reads指的是一条reads可以map到基因组上的不同位置，包含supplementary reads的情况，异常map的flag值是256；用baw mem -M参数可以mark supplementary reads使其变为secondary reads，也即flag值从2048变为256，这样有利于利用这些reads做变异检测，否则这些reads会被丢弃Umap and Bismap mappabilityRefer to this site这个map的目的是标记整个基因组上highly mappable的位置，也即可以被特定长度的k-mer特异性map的位置。方法是首先产生一个基因组上可能有的所有k-mer，然后将这些k-mer用bowtie2 map回基因组上，标记那些只map到基因组上一个位置的k-mer的起始位置。结果中1表示这个位置是uniquely mappable，0表示这个位置产生的k-mer可以map到基因组上的其他地方。Subsample reads from bam filesamtools view --subsample 0.01 in.bam &gt; out.bambeffroni and BH (FDR) correctionbeffroni校正是用P值直接除以总的test数BH是先对P值进行排序，然后用P值除以test数再乘以P值的秩可以参考这篇文章Bowtie2 alignment report详解Bowtie2的比对Summary aligned concordantly 0 times，也即合理匹配0次，表示双端reads不能合理匹配上，在这种情况下，bowtie2一方面会报告这些reads中可以不合理匹配上的reads，另一方面会将双端reads拆分成单端reads继续align，并且报告单端reads可以匹配上的数量。 aligned concordantly exactly 1 times，表示合理匹配且只匹配到基因组上的一个位置的reads。 aligned concordantly &gt;1 times，表示有些双端reads可以匹配到基因组上的多个位置。 overall alignment rate = (合理匹配一次readsx2 + 多重匹配readsx2 + 不合理匹配readsx2 + 单端匹配reads) / 总双端readsx2" }, { "title": "Biology", "url": "/posts/Biology/", "categories": "", "tags": "Basic concepts", "date": "2022-05-25 00:00:00 +0000", "snippet": "Understand sense and antisense strandHow to understand the relationship between sense strand, mRNA, codon, UTR. 如何理解搞懂codon，cds，mRNA，sense strand，ATG，AUG之间的关系 DNA有双链，其中一条会被用作模板转录RNA，这条链叫模板链、非编码链和反义链(antisense strand)，另外一条链就叫非模板链，编码链和正义链(sense strand)，这一条链除了T/U的区别和mRNA中的碱基序列一致。一条DNA序列可以分为编码区和非编码区，编码区又分为内含子(intron)和外显子(exon)，经过剪切的成熟mRAN包含蛋白编码区cds(protein coding sequence)和UTR区(untranslated region)，在cds上会有一个翻译起始密码子也即AUG(Met/M)/GUG(Val/V)，会有一个翻译终止密码子也即UAA/UAG/UGA。Understand LDLD - linkage disequilibrium(可以参考这篇文章)[https://cloud.tencent.com/developer/article/1625934]总结就是 连锁不平衡表示两个基因的遗传不服从哈代温伯格定律，发生了连锁现象，导致这两个基因的某种单体型概率变大，一般发生在距离相近的两个基因间。 有两个参数可以表征LD，一个是D值，另一个是r2，两个值趋近1表示完全连锁不平衡，即两个基因遗传时完全绑定" }, { "title": "Mamba Usage Notebook", "url": "/posts/Mamba-learning/", "categories": "Conda", "tags": "Mamba", "date": "2022-05-18 00:00:00 +0000", "snippet": "Almost all commands in conda could be replaced by mamba, except activation and deactivation still using condacreate a environmentmamba create -n nameofmyenv &lt;list of packages&gt;install further packagesmamba install otherpkgsinstall packages through channelsmamba install -c bioconda samtoolsremove a environmentmamba remove -n snakemake-tutorial --all" }, { "title": "Snakemake Tutorial", "url": "/posts/Snakemake-learning-notes/", "categories": "Pipeline", "tags": "Tutorial, Snakemake", "date": "2022-05-10 00:00:00 +0000", "snippet": "This post records the learning of Snakemake. Refered to this tutorialThe first and the most important thing is that you know how to do the thing logically, sequences, tools and their version, input and output, parameters and log files.Keep in mind that Snakemake could help you build a workflow that make the analysis reproducible, but itself does not analyze anything.InstallRecommand install through conda or mamba, it is better to create a isolated environmentconda install -c conda-forge mambamamba install -c bioconda snakemakeExample files from Snakemake tutorialConfig fileStore global variables in dictionary, can be wrote in JSON or YAMLsamples: A: data/samples/A.fastq B: data/samples/B.fastqprior_mutation_rate: 0.001SnakefileMain part of snakemake workflow, containing all rules need to be excuted, use include to include other Snakemake filesconfigfile: \"config.yaml\"# localrules all require all intended output, it will not be submitted to clusterlocalrules: allrule all: input: \"plots/quals.svg\"# input function, enable us to process input files, like add if to filter based on some conditionsdef get_bwa_map_input_fastqs(wildcards): return config[\"samples\"][wildcards.sample]# generally, for one rule, input, output, params, threads are necessary; log and benchmark# could be used to record the running information; conda could indicate specific environment;# four ways to run: shell, script, wrapper and directly write Python code.# {sample} here is a wildcard, snakemake will automatically determine the content of wildcard# based on the whole workflow. In rule all, wildcard can not be used, it needs explicit target.rule bwa_map: input: \"data/genome.fa\", get_bwa_map_input_fastqs output: temp(\"mapped_reads/{sample}.bam\") params: rg=r\"@RG\\tID:{sample}\\tSM:{sample}\" log: \"logs/bwa_mem/{sample}.log\" threads: 8 shell: \"(bwa mem -R '{params.rg}' -t {threads} {input} | \" \"samtools view -Sb - &gt; {output}) 2&gt; {log}\"# temp() tell snakemake to delete the intermediate files after no process is dependent on them# protected() could protect the important files in case they are deleted or covered accidently.# {sample} and {wildcards.sample} are equivalent here.rule samtools_sort: input: \"mapped_reads/{sample}.bam\" output: protected(\"sorted_reads/{sample}.bam\") shell: \"samtools sort -T sorted_reads/{wildcards.sample} \" \"-O bam {input} &gt; {output}\"rule samtools_index: input: \"sorted_reads/{sample}.bam\" output: \"sorted_reads/{sample}.bam.bai\" shell: \"samtools index {input}\"# expand() is a very useful function, it returns a list# multiext is variant of expand(), it is useful in reference index# usage: multiext(\"refs/genome\", \".fa\", \".fa.fai\", \".bwt\")# use a () to put all commands in shell to one, then log can log everything happened.rule bcftools_call: input: fa=\"data/genome.fa\", bam=expand(\"sorted_reads/{sample}.bam\", sample=config[\"samples\"]), bai=expand(\"sorted_reads/{sample}.bam.bai\", sample=config[\"samples\"]) output: \"calls/all.vcf\" params: rate=config[\"prior_mutation_rate\"] log: \"logs/bcftools_call/all.log\" shell: \"(bcftools mpileup -f {input.fa} {input.bam} | \" \"bcftools call -mv -P {params.rate} - &gt; {output}) 2&gt; {log}\"rule plot_quals: input: \"calls/all.vcf\" output: \"plots/quals.svg\" script: \"scripts/plot-quals.py\"# wrapper is pre-compiled tool distributed in snakemake-wrapper. The pattern of whole rule# should be identical to what has been defined in wrapper, or it will throw errors. When# running, snakemake will automatically download a conda env to run the tool. You can sepcify# the path for conda env in command line `snakemake --conda-env /a/path/to/`rule bwa_mem: input: ref=\"data/genome.fa\", sample=lambda wildcards: config[\"samples\"][wildcards.sample] output: temp(\"mapped_reads/{sample}.bam\") log: \"logs/bwa_mem/{sample}.log\" params: \"-R '@RG\\tID:{sample}\\tSM:{sample}'\" threads: 8 wrapper: \"0.15.3/bio/bwa/mem\"Environment fileEnvironment file for specific tool to run: envs/samtools.yaml, used under conda parameter.channels: - bioconda - conda-forgedependencies: - samtools =1.9Snakemake execution snakemake -np, dry run and print shell commands, if --cores command is given without a number, all available cores are used snakemake targetfiles --cores 8, run for single specific targets, snakemake will automatically find dependency snakemake somerules --core 8, run specific rules, the output of the rule will be the target --forceall, force to re-run specific rules or targets snakemake --use-conda --cores 1, will automatically create required environments and activate them before a job is executed snakemake --dag | dot -Tpdf &gt; dag.pdf or snakemake --dag | dot -Tsvg &gt; dag.svg, build a graph showing the workflow logic snakemake --cluster qsub --jobs 10, run snakemake in clusters snakemake --use-conda --cores 4 --conda-frontend mamba --conda-prefix ~/data/biosoft/grenepipe/conda-envs --directory example/, a complicated but useful snakemake run Snakemake automatically creates missing directories before jobs are executed Additional features use include to include other Snakefile into current one, this feature enable us to separate a large workflow into small pieces under script parameter, in Python script we can access Snakemake properties by like snakemake.input[0], or we can do that in R script by snakemake@input[[1]]One good snakemake example - GrenePipegit clone https://github.com/moiexpositoalonsolab/grenepipe.gitconda install mamba -n base -c conda-forgemamba env create -f envs/grenepipe.yamlconda activate grenepipecd grenepipe./example/prepare.shsnakemake --use-conda --cores 4 --conda-frontend mamba --conda-prefix ~/data/biosoft/grenepipe/conda-envs --directory example/ 2&gt;2.log" }, { "title": "Make Tutorial", "url": "/posts/Make-learning-notes/", "categories": "Pipeline", "tags": "Tutorial, Make", "date": "2022-05-08 00:00:00 +0000", "snippet": "This post is a summary of this awesome Make tutorialMake is a tool which can run commands to read files, process these files in some way, and write out the processed files.Make is called a build tool - it builds data files, plots, papers, programs or libraries. It can also update existing files if desired.Make tracks the dependencies between the files it creates and the files used to create these. If one of the original files (e.g. a data file) is changed, then Make knows to recreate, or update, the files that depend upon this file (e.g. a plot).MakefilesComponents: rules, targets, dependencies and actionstarget : dependency\tactionsIn Makefile, the first target is the default target Make attempts to build.phony target - tell Make always execute this rule no matter the target exists or not..PHONY : cleanclean :\trm -f *.dat The order of rebuilding dependencies is arbitrary. You should not assume that they will be built in the order in which they are listed.Dependencies must form a directed acyclic graph. A target cannot depend on a dependency which itself, or one of its dependencies, depends on that target.up to date means that the Makefile has a rule with one or more actions whose target is the name of a file (or directory) and the file is up to date.Nothing to be done means that the file exists but either : the Makefile has no rule for it, or the Makefile has a rule for it, but that rule has no actionsmake -n, dry run, print the command but not runAutomatic Variables $@ is a Make automatic variable which means ‘the target of the current rule’. When Make is run it will replace this variable with the target name. $^ is another automatic variable which means ‘all the dependencies of the current rule’. Again, when Make is run it will replace this variable with the dependencies. $&lt; means ‘the first dependency of the current rule’. Dependencies on Data and CodeDry run: make can show the commands it will execute without actually running them if we pass the -n flagKey points Make results depend on processing scripts as well as data files. Dependencies are transitive: if A depends on B and B depends on C, a change to C will indirectly trigger an update to A.Pattern Rules% is a Make wildcard. $* is a special variable which gets replaced by the stem with which the rule matched. The Make % wildcard can only be used in a target and in its dependencies. It cannot be used in actions. In actions, you may however use $*, which will be replaced by the stem with which the rule matched.Variables$(...) tells Make to replace a variable with its value when Make is runWe can pull variables out into a new file that just holds variable definitions - config.mkWe can then import config.mk into Makefile using: include config.mkFunctionswildcard. is function that gets a list of files matching some pattern, which we can then save in a variable. For exampleTXT_FILES=$(wildcard books/*.txt) @echo Make prints actions as it executes them. Using @ at the start of an action tells Make not to print this action. So, by using @echo instead of echo, we can see the result of echo (the variable’s value being printed) but not the echo command itself.patsubst (‘pattern substitution’) takes a pattern, a replacement string and a list of names in that order; each name in the list that matches the pattern is replaced by the replacement string. Again, we can save the result in a variable. For exampleDAT_FILES=$(patsubst books/%.txt, %.dat, $(TXT_FILES))Self-Documenting MakefilesProvide a help target in MakefilesWe can use ## (or even ###) for comments that describe what a rule does and that we want sed to detect, for example.PHONY : helphelp : Makefile\t@sed -n 's/^##//p' $&lt;" }, { "title": "李东风R教程学习笔记", "url": "/posts/Lidongfeng-R-learning-notes/", "categories": "R", "tags": "LearningNotes", "date": "2022-05-07 00:00:00 +0000", "snippet": "教程地址安装R指定镜像网站options(repos=c(CRAN=\"https://mirror.tuna.tsinghua.edu.cn/CRAN/\"))install.packages(\"sos\")安装包时指定镜像网站和安装路径install.packages(\"sos\", repos=\"\", lib=\"\")保存数据# save all objects in environmentsave.image(\"to/path/all_data.Rdata\")load(\"to/path/all_data.Rdata\")# save several objectssave(data1, data2, \"to/path/two_objects.Rdata\")load(\"to/path/two_objects.Rdata\")# save single object, both save() and saveRDS() work, but readRDS() could set a new name to objectsaveRDS(data1, \"to/path/single_object.Rdata\")new_data_load &lt;- readRDS(\"to/path/single_object.Rdata\")数据类型与相应计算R是“动态类型”语言， 赋值实际上是“绑定”（binding）， 即将一个变量名与一个存储地址联系在一起， 同一个存储地址可以有多个变量名与其联系数值型向量及其运算numeric()函数可以用来初始化一个指定元素个数而元素都等于零的数值型向量， 如numeric(10)会生成元素为10个零的向量vector(\"list\", 10)函数可以用来初始化一个有10个元素的空列表常用的数学函数: 舍入： ceiling, floor, round, signif, trunc, zapsmall 符号函数 sign 绝对值 abs 平方根 sqrt 对数与指数函数 log, exp, log10, log2 三角函数 sin, cos, tan 贝塔函数 beta 伽玛函数 gamma如果自己编写的函数没有考虑向量化问题， 可以用Vectorize()函数将其转换成向量化版本排序函数: sort(x)返回排序结果。 rev(x)返回把各元素排列次序反转后的结果。 order(x)返回排序用的下标 gtools::mixedsort(c(\"v10\", \"v7\", \"v2\"))可以按字符中的数字进行排序统计函数: sum(求和), mean(求平均值), var(求样本方差), sd(求样本标准差), min(求最小值), max(求最大值), range(求最小值和最大值), prod求所有元素的乘积, cumsum和cumprod计算累加和累乘积生成规则序列的函数： seq, rep逻辑型向量及其运算函数match(x, y)起到和x %in% y运算类似的作用，返回x中的每个元素在y中首次出现的下标，找不到时取NA用xor(x, y)表示x与y的异或运算，即值不相等时为真值，相等时为假值，有缺失值参加运算时为缺失值&amp;&amp;和||分别为短路的标量逻辑与和短路的标量逻辑或，仅对两个标量进行运算，如果有向量也仅使用第一个元素。 一般用在if语句、while语句中，且只要第一个比较已经决定最终结果就不计算第二个比较函数which()返回真值对应的所有下标函数identical(x,y)比较两个R对象x与y的内容是否完全相同，结果只会取标量TRUE与FALSE两种函数duplicated()返回每个元素是否为重复值的结果用函数unique()可以返回去掉重复值的结果字符型数据及其处理一些常用函数paste(sep=\" \", collapse=\"\"), paste0()toupper(), tolower()substr(x, start, stop)strsplit(x, string, fixed=FALSE)as.numeric(), as.character(), sprintf()格式化gsub(pattern, replace, x)可以替换字符串中的子串把多于一个空格替换成一个空格gsub('[[:space:]]+', ' ', 'a cat in a box', perl=TRUE)R向量下标和子集which.min、which.max求最小值的下标和最大值的下标用unname(x)返回去掉了元素名的x的副本， 用names(x) &lt;- NULL可以去掉x的元素名R数据类型的性质NULL值表示不存在。 NULL长度为0，不能有任何属性值NA是有类型的（integer、double、logical、character等), NA表示存在但是未知类型升档:在用c()函数合并若干元素时，如果元素基本类型不同，将统一转换成最复杂的一个，复杂程度从简单到复杂依次为：logical &lt; integer &lt; double &lt; character除了NULL以外，R的变量都可以看成是对象，都可以有属性。 常用属性有names, dim，class等可以用attributes()读取对象x的所有属性可以用attr(x, \"属性名\")的格式读取或定义x的属性取矩阵子集时如果结果仅有一列或一行， 除非用了drop=FALSE选项， 结果不再有dim属性， 退化成了普通向量。R具有一定的面向对象语言特征，其数据类型有一个class属性,函数class()可以返回变量类型的类属str()函数可以显示对象的类型和主要结构及典型内容R日期时间因为我们平时不怎么遇到时间相关的转化或计算问题，所以这部分的内容大概了解一下就可以了R扩展包lubridate提供了多个方便函数， 可以更容易地生成、转换、管理日期型和日期时间型数据lubridate::ymd(), lubridate::mdy(), lubridate::dmy()将字符型向量转换为日期型向量lubridate::make_date(year, month, day)可以从三个数值构成日期向量as.character()中可以用format选项指定显示格式lubridate包中的wday()可以取出日期在一个星期内的序号，但是一个星期从星期天开始，星期天为1,星期一为2，星期六为7，例如wday(as.POSIXct(\"2018-1-17 13:15:40\"))为4表示星期三日期计算在lubridate的支持下日期可以相减，可以进行加法、除法lubridate的dseconds(), dminutes(), dhours(), ddays(), dweeks(), dyears()函数可以直接生成时间长度类型的数据用unclass()函数将时间长度数据的类型转换为以秒为单位的普通数值lubridate提供了%--%运算符构造一个时间区间。 时间区间可以求交集、并集等生成时间区间， 也可以用lubridate::interval(start, end)函数把一个R日期时间值用as.POSIXlt()转换为POSIXlt类型， 就可以用列表元素方法取出其组成的年、月、日、时、分、秒等数值R因子类型factor因子的levels属性可以看成是一个映射，把整数值1,2,映射成这些水平值，因子在保存时会保存成1,2,等与水平值对应的编号为了对因子执行字符型操作（如取子串），保险的做法是先用as.character()函数强制转换为字符型factor(x, levels = sort(unique(x), na.last = TRUE), labels, exclude = NA, ordered = FALSE)cut()连续取值的变量，可以用cut()函数将其分段，转换成因子。 使用breaks参数指定分点，最小分点要小于数据的最小值，最大分点要大于等于数据的最大值，默认使用左开右闭区间分组可以指定breaks为一个正整数，表示将数据范围略扩大后进行等间距分组为了实现各组个数比较平均的分组，可以利用quantile()函数计算分位数作为分组forcats包的因子函数forcats::fct_reorder()可以根据不同因子水平分成的组中另一数值型变量的统计量值排序set.seed(1)fac &lt;- sample(c(\"red\", \"green\", \"blue\"), 30, replace=TRUE)fac &lt;- factor(fac, levels=c(\"red\", \"green\", \"blue\"))x &lt;- round(100*(10+rt(30,2)))fac2 &lt;- forcats::fct_reorder(fac, x, sd)# 将特定的一个或几个水平次序放到因子水平最前面fac3 &lt;- fct_relevel(fac, \"blue\")# 修改每个水平的名称fac4 &lt;- fct_recode(fac, \"红\"=\"red\", \"绿\"=\"green\", \"蓝\"=\"blue\")# 合并原来的水平fct_collapse()列表类型# 把某个列表元素赋值为NULL就删掉这个元素rec &lt;- list(name=\"李明\", age=30, scores=c(85, 76, 90))rec[[\"age\"]] &lt;- NULL# 在list()函数中允许定义元素为NULL，这样的元素是存在的li &lt;- list(a=120, b=\"F\", c=NULL)# 也可以把已经存在的元素修改为NULL值而不是删除此元素li[\"b\"] &lt;- list(NULL)用as.list()把一个其它类型的对象转换成列表； 用unlist()函数把列表转换成基本向量，注意这个函数会解压所有的列表元素到一个向量中R矩阵和数组 对矩阵A，diag(A)访问A的主对角线元素组成的向量。 另外，若x为正整数值标量，diag(x)返回x阶单位阵； 若x为长度大于1的向量， diag(x)返回以x的元素为主对角线元素的对角矩阵 若x是向量，cbind(x)把x变成列向量，即列数为1的矩阵，rbind(x)把x变成行向量 对两个同形状的矩阵， 用*表示两个矩阵对应元素相乘(注意这不是线性代数中的矩阵乘法)， 用/表示两个矩阵对应元素相除 用%*%表示矩阵乘法而不是用*表示， 注意矩阵乘法要求左边的矩阵的列数等于右边的矩阵的行数 设x, y是两个向量， 计算向量内积， 可以用sum(x*y)表示 用solve(A)求A的逆矩阵用solve(A,b)求解线性方程组Ax = b 中的xapply()函数apply(A, 2, FUN), 把矩阵或者数据框A的每一列分别输入到函数FUN中，得到对应于每一列的结果apply(A, 1, FUN), 把矩阵或者数据框A的每一行分别输入到函数FUN中，得到与每一行对应的结果多维数组# 三维数组ara可以看成是4个2X3矩阵ara &lt;- array(1:24, dim=c(2,3,4))数据框在R markdown文件中，可以将数据框保存的表格显示为富文本格式，方法是使用knitr::kable()函数split(x, f)函数可以将向量或者数据框x按照f拆分，f可以是一组因子向量也可以是数据框中的一个变量，返回一个列表tibble从tibble取出的一列结果仍是tibble而不是向量， 为了提取一列为向量应使用双方括号格式或$格式编程模块R输入输出cat()函数可以把字符串、变量、表达式连接起来显示,有file=和append=TRUE两个参数read_csv()函数：参数skip=, locale=locale(),col_names=,col_types.read_table2()读入用空格作为间隔的文本文件，同一行的两个数据项之间可以用一个或多个空格分隔，不需要空格个数相同，也不需要上下对齐程序控制结构 分支结构：if-else, ifelse(), dplyr::case_when()相当于ifelse的多分支推广，在mutate中需要根据条件定义一个新的变量的时候很有用 循环结构：for, 如果需要对某个向量x按照下标循环，获得所有下标序列的标准写法是seq_along(x) while()和repeat # 用泰勒展开逼近计算e的值e0 &lt;- exp(1.0)s &lt;- 1.0x &lt;- 1k &lt;- 0repeat{k &lt;- k+1x &lt;- x/ks &lt;- s + x if(x &lt; .Machine$double.eps) break}err &lt;- s - e0cat(\"k=\", k, \" s=\", s, \" e=\", e0, \" 误差=\", err, \"\\n\") 如果对向量每个元素遍历并保存结果，应在循环之前先将结果变量产生等长的存储，在循环内为已经分配好存储空间的输出向量的元素赋值。为了产生长度为n的数值型向量，用numeric(n)； 为了产生长度为n的列表，用vector(\"list\", n)if和while中用到的条件必须是标量值，而且必须为TRUE or FALSE管道控制R从4.1.0版本开始提供了一个|&gt;运算符实现管道控制函数函数名 &lt;- function(形式参数表) 函数体，函数也是一个对象从R 4.1.0版本开始，简单的R函数还可以写成\\(x) 表达式的形式, 用\\(x)代替function(x)关键字函数体的最后一个表达式是函数返回值, 为了返回多个变量值，将这些变量打包为一个列表返回即可函数定义中的自变量叫做形式参数或形参(formal arguments)。 函数调用时，形式参数得到实际值，叫做实参(actual arguments)formals()可以查看函数的形式参数表R中在递归调用时，最好用 Recall() 代表调用自身，这样保证函数即使被改名（在R中函数是一个对象，改名后仍然有效）递归调用仍指向原来定义R中的无名函数类似于Python中的lambda匿名函数，只要function(形式参数)就可以do.call(fun, list)函数是用list中的所有元素作为fun的参数执行，因为list这个数据结构包容万物，所以这个函数在某些时候很有用，比如按行合并一个列表中的所有元素时，还可以用来优雅的处理函数的可选参数，具体讲解和例子可以参考这篇优秀的推送变量作用域ls(pattern=\"^tmp[.]\")显示所有以tmp.开头的变量在函数内部如果要修改全局变量的值，用 &lt;&lt;-代替&lt;-进行赋值R程序效率向量化编程尽量用R中内置的向量化的函数减少显式循环replicate()函数可以用来执行某段程序若干次,一个例子：set.seed(1)replicate(6, { x &lt;- rnorm(5, 0, 1); c(mean(x), sd(x)) })避免制作副本 事先分配好用来保存结果的数据结构，在每次循环中填入相应结果 在循环内修改数据框的值会制作数据框副本，修改列表元素不会制作副本R的计算函数数学函数概括函数 cumsum和cumprod计算累计，得到和输入等长的向量结果 diff计算前后两项的差分 quantile计算样本分位数, cor计算相关系数 colSums, colMeans, rowSums, rowMeans对矩阵的每列或每行计算总和或者平均值最值 pmax(x1,x2,…)对若干个等长向量计算对应元素的最大值排序 sort返回排序结果 order返回排序用的下标序列 unique()返回去掉重复元素的结果，duplicated()对每个元素用一个逻辑值表示是否与前面某个元素重复 rev反转序列 rank计算秩统计量一元定积分integrate(f, lower, upper)对一元函数f计算从lower到upper的定积分用filter函数作迭代向量自身迭代函数进阶 任何成分都是R的对象 任何活动都是调用函数句法作用域(lexical scoping)， 即函数运行中需要使用某个变量时， 从其定义时的环境向外层逐层查找， 而不是在调用时的环境中查找动态查找(dynamic lookup)，函数运行时在找到某个变量对应的存储空间后， 会使用该变量的当前值，而不是函数定义的时候该变量的历史值辅助嵌套函数：只能在定义它的函数内运行， 不能被直接调用， 可以看成是函数内的私有函数懒惰求值：懒惰求值使得缺省值在初次访问时， 是在函数内的环境（局部变量作用域）内求值的， 不是在其调用处的环境内求值将每一个小问题编写成一个单独的函数，编写一系列的测试函数， 对每个函数进行测试，最好能有自动化的测试策略程序调试在函数中加browser()可以进行断点调试，在调试命令行输入变量名查看变量值；用n命令或者换行键逐句运行；用s命令跟踪进调用的函数内部逐句运行；用f命令快速执行到循环末尾或者函数末尾；用c命令恢复正常运行，不再跟踪；用Q命令强行终止程序运行。条件断点: 用browser()函数与R的if结构配合可以制作条件断点stop()、warning()、message()，停止，警告和提示函数stopifnot可以指定自变量的若干个条件， 当自变量不符合条件时自动出错停止。类似于Python中的assert泛函（functionals）使用purrr包中的map函数及其变种进行各种泛函分析。map函数要求的输入格式是map(data, function), map总是返回列表map变种及其性质 map_lgl：返回逻辑向量 map_int：返回整型向量 map_dbl: 返回双精度浮点型向量(double类型) map_chr: 返回字符型向量 modify: 输出的数据类型与输入的数据类型一致，可用于对数据框特定列进行修改，如modify(dataframe, ~ if(is.numeric(.x) .x-median(.x) else .x)，可以先判断是否是数值型列，然后每一项减去中位数，也可以用modify的变种modify_if()写作modify_if(dataframe, is.numeric, ~ .x-median(.x)) map2: 支持两个输入自变量，输出也是一个列表，若提前已知输出类型，可用相应变种指定输出类型 walk: 狭义上讲，这个函数不产生输出也即不返回数据，适用于一些作图和保存数据到文件的情况，如d.class %&gt;% split(d.class, d.class[['sex']]) %&gt;% walk(paste0(\"class\", names(.), '.csv'), ~ write.csv(.x, file=.y))，这条命令首先将一个数据框按某一列分成两个，然后将分开的数据框分别写到两个文件中 imap: 如果x有元素名，imap(x, f)相当于map2(x, names(x), f)； 如果x没有元素名，imap(x, f)相当于map2(x, seq_along(x), f) pmap: 支持多个输入自变量 ...： 形参, 一个例子理解一下：map_dbl(d.class[,3:5], mean, trim=0.10)中的trim=0.10就是map函数的...形参purrr::reduce函数: 可以用来对输入列表或向量的元素逐次的用给定的函数进行合并运算，类似于用sum和prod进行累加和累乘purrr::accumulate函数: 就像reduce函数是sum的推广，accumulate函数就像是cumsum的推广示性函数：返回逻辑向量的函数，示性函数可以作为泛函的输入，purrr包中以示性函数为输入的泛函有 keep(.x, .p): 保留满足.p条件的元素 discard: 与keep相反基本R中的泛函： apply类函数 apply(x, 2, fun): 输入矩阵或数据框，返回矩阵或数据框 lapply(x, fun, ...): 输入列表，返回列表，...表示可以添加参数到fun中 sapply(): 优先尝试返回向量或矩阵，不可行时才返回列表 mapply(): 可以支持多个输入自变量，类似于map2函数工厂是指返回函数的函数取颜色library(RColorBrewer)display.brewer.all()display.brewer.pal(n = 8, name = 'Dark2')brewer.pal(n = 8, name = \"Dark2\")# \"#1B9E77\" \"#D95F02\" \"#7570B3\" \"#E7298A\" \"#66A61E\" \"#E6AB02\" \"#A6761D\" \"#666666\"colorRampPalette(brewer.pal(8,\"Dark2\"))(9)# \"#1B9E77\" \"#C16610\" \"#8D6B86\" \"#BC4399\" \"#A66753\" \"#96A713\" \"#D59D08\" \"#9D7426\" \"#666666\"# 通过这种方法可以构建新的颜色板然后从其中取任意数量的颜色批量读入文件，合并到一个数据框中# 这里以读入三个read depth文件为例listfiles &lt;- dir(path = 'depth', pattern = paste0('^', 'Sample_', samplename), full.names = T)listdepth &lt;- vector('list', length = 3)for (i in seq_along(listdepth)) { listdepth[[i]] &lt;- read.delim(listfiles[[i]], col.names = c('ref','position','depth'), header = F)}avgDepth &lt;- do.call(rbind, listdepth)Ctrl+Alt+Shift+R插入函数文档注释 https://zhuanlan.zhihu.com/p/150568854" }, { "title": "廖雪峰Python3教程学习笔记", "url": "/posts/LiaoXuefeng-Python-learning-notes/", "categories": "Python3", "tags": "LearningNotes", "date": "2022-05-07 00:00:00 +0000", "snippet": "教程地址学完之后体会： 这部教程前面的基础部分讲解的很详细，很适合入门 对生信研究人员来说看到常用内建模块那一章就可以了，后面的内容在生信里应用不多 但是后半部分的内容才是Python真正的优势所在Python基础字符串和编码ASCII编码：编码英文Unicode编码：编码所有字符UTF-8编码：可变长编码编码所有字符最早的计算机在设计时采用8个比特（bit）作为一个字节（byte），所以，一个字节能表示的最大的整数就是255（二进制11111111=十进制255）ASCII编码和Unicode编码的区别：ASCII编码是1个字节，而Unicode编码通常是2个字节本着节约的精神，又出现了把Unicode编码转化为“可变长编码”的UTF-8编码,UTF-8编码把一个Unicode字符根据不同的数字大小编码成1-6个字节，常用的英文字母被编码成1个字节，汉字通常是3个字节，只有很生僻的字符才会被编码成4-6个字节UTF-8编码有一个额外的好处，就是ASCII编码实际上可以被看成是UTF-8编码的一部分，所以，大量只支持ASCII编码的历史遗留软件可以在UTF-8编码下继续工作。由于Python源代码也是一个文本文件，所以，当你的源代码中包含中文的时候，在保存源代码时，就需要务必指定保存为UTF-8编码。当Python解释器读取源代码时，为了让它按UTF-8编码读取，我们通常在文件开头写上这两行：#!/usr/bin/env python3# -*- coding: utf-8 -*-用format()格式化字符串：str.format(),通过 {} 和 : 来代替以前的 %, 一颗栗子\"{:d}\".format(24)，更多例子如下数据结构list: 常用方法 append, insert, poptuple: 类似于list，但其中元素不可变dict: 一个内置方法可以判断key是否存在 - dict.get(‘a’,-1),若不存在返回-1set: 相当于一个没有value的字典，其中元素不可重复且无序，故可以进行交集并集等操作列表是可变对象，对其进行的操作会直接改变其中的内容，元组和字符串还有dict的key是不可变对象函数可以import同一个文件夹中.py文件中的函数：from file.py import a_function数据类型检查可以用内置函数isinstance()实现Python的函数返回多值其实就是返回一个tuple参数必选参数(位置参数)默认参数 默认参数：定义默认参数要牢记一点：默认参数必须指向不变对象！# 默认参数，默认参数一定要放在位置参数后面# 调用时，默认参数可以给名字也可以不给，不按顺序提供默认参数时必须要给名字def power(x, n=2): s = 1 while n &gt; 0: n = n - 1 s = s * x return spower(2, 5)# 可变参数，在函数内部，可变参数接收到的是一个tupledef calc(*numbers): sum = 0 for n in numbers: sum = sum + n * n return sumcalc(1,2,3,4)nums=[1,2,3]calc(*nums)# 关键字参数，在函数内部，可变参数接收到的是一个dictdef person(name, age, **kw): print('name:', name, 'age:', age, 'other:', kw)person('sunjh', 26, add=\"shenzhen\", hobby=\"badminton\")jh = {add:'shenzhen', hobby:'badminton'}person('sunjh', 26, **jh)# 命名关键字参数：含参数名的关键字参数，使用命名关键字参数时，要特别注意，如果没有可变参数，就必须加一个`*`作为特殊分隔符，# 如果有可变参数，就不用`*`分隔符；# 命名关键字在调用时必须给出名字def person0(name, age, *, city, job): print(name, age, city, job)person('sunjh', 26, city='shenzhen', job='student')def person1(name, age, *args, city, job): print(name, age, args, city, job)# 可以设置缺省值def person2(name, age, *, city='Beijing', job): print(name, age, city, job)在Python中定义函数可以组合使用上述五种参数，但是参数定义的顺序必须是：位置参数、默认参数、可变参数、命名关键字参数、关键字参数对于任意函数，无论它的参数是如何定义的，都可以通过类似func(*args, **kw)的形式调用它递归函数使用递归函数的优点是逻辑简单清晰，缺点是过深的调用会导致栈溢出。针对尾递归优化的语言可以通过尾递归防止栈溢出。尾递归事实上和循环是等价的，没有循环语句的编程语言只能通过尾递归实现循环。Python标准的解释器没有针对尾递归做优化，任何递归函数都存在栈溢出的问题。一个经典的递归函数问题：汉诺塔，尝试一下用递归函数实现吧！高级特性始终牢记，代码越少，开发效率越高切片迭代: enumerate函数列表生成式: 在一个列表生成式中，for前面的if ... else是表达式，而for后面的if是过滤条件，不能带else生成器(generator)列表生成器：把列表生成式中的[]改成()即可生成器函数：yield关键字用生成器写一个杨辉三角吧！def triangles():\tL = [1]\twhile True:\t\tyield L\t\tL = [1] + [L[n] + L[n+1] for n in range(len(L)-1)] + [1]迭代器凡是可作用于for循环的对象都是Iterable类型可以被next()函数调用并不断返回下一个值的对象称为迭代器：Iterator。把list、dict、str等Iterable变成Iterator可以使用iter()函数函数式编程函数就是面向过程的程序设计的基本单元函数式编程就是一种抽象程度很高的编程范式，纯粹的函数式编程语言编写的函数没有变量，因此，任意一个函数，只要输入是确定的，输出就是确定的，这种纯函数我们称之为没有副作用。而允许使用变量的程序设计语言，由于函数内部的变量状态不确定，同样的输入，可能得到不同的输出，因此，这种函数是有副作用的。函数式编程的一个特点就是，允许把函数本身作为参数传入另一个函数，还允许返回一个函数！高阶函数函数本身也可以赋值给变量，即：变量可以指向函数既然变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数编写高阶函数，就是让函数的参数能够接收别的函数。map/reducemap()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回reduce把一个函数作用在一个序列[x1, x2, x3, ...]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算一个将字符串转化成整数的函数from functools import reduceDIGITS = {'0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9}def char2num(s):\treturn DIGITS[s]def str2in(s):\treturn reduce(lambda x, y: x * 10 + y, map(char2num, s))一个将字符串转化成浮点数的函数from functools import reduceDIGITS = {'0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9}def char2num(s):\treturn DIGITS[s]def str2float(s):\ti = s.index('.')\tn = len(s) - i - 1\tf1 = reduce(lambda x, y: x * 10 + y, map(char2num, s[:i]))\tf2 = reduce(lambda x, y: x * 10 + y, map(char2num, s[i+1:]))\treturn f1 + f2 / (10 ** n)filterfilter()函数用于过滤序列,filter()把传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素产生一个素数序列def _odd_iter(): n = 1 while True: n = n + 2 yield ndef _not_divisible(n): return lambda x: x % n &gt; 0def primes(): yield 2 it = _odd_iter() # 初始序列 while True: n = next(it) # 返回序列的第一个数 yield n it = filter(_not_divisible(n), it) # 构造新序列 # 打印1000以内的素数:for n in primes(): if n &lt; 1000: print(n) else: break筛选回数def is_palindrome(n):\tn = str(n)\tl = len(n)\tif l == 1:\t\treturn True\telif l % 2 == 0:\t\tindex = int(l/2)\t\tfor i in range(index):\t\t\tif n[i] != n[-(i+1)]:\t\t\t\treturn False\t\treturn True\telse:\t\tindex = int((l-1)/2)\t\tfor i in range(index):\t\t\tif n[i] != n[-(i+1)]:\t\t\t\treturn False\t\treturn True# A simpler way:def is_palindrome(n):\treturn n == int(str(n)[::-1])huisu = list(filter(is_palindrome, [i for i in range(200)]))sortedsorted()函数可以对list进行排序,它可以接收一个key函数来实现自定义的排序返回函数高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回。返回求和的函数def lazy_sum(*args): def sum(): ax = 0 for n in args: ax = ax + n return ax return sumf = lazy_sum(1, 3, 5, 7, 9)f()注意一点，当我们调用lazy_sum()时，每次调用都会返回一个新的函数，即使传入相同的参数闭包（Closure）- 闭包的意义是什么？当一个函数返回了一个函数后，其内部的局部变量还被新函数引用 返回闭包时牢记一点：返回函数不要引用任何循环变量，或者后续会发生变化的变量。使用闭包，就是内层函数引用了外层函数的局部变量。如果只是读外层变量的值，我们会发现返回的闭包函数调用一切正常.但是，如果对外层变量赋值，由于Python解释器会把x当作函数fn()的局部变量，而x没有提前定义，它会报错. 使用闭包时，对外层变量赋值前，需要先使用nonlocal声明该变量不是当前函数的局部变量。用闭包返回一个计数器函数，每次调用它返回递增整数def createCounter(): count = 0 def counter(): nonlocal count count = count + 1 return count return counter匿名函数lambda: 匿名函数有个限制，就是只能有一个表达式，不用写return，返回值就是该表达式的结果装饰器 - Decorator函数也是一个对象，而且函数对象可以被赋值给变量本质上，decorator就是一个返回函数的高阶函数借助Python的@语法，把decorator置于函数的定义处一个栗子def log(func): def wrapper(*args, **kw): print('call %s():' % func.__name__) return func(*args, **kw) return wrapper@logdef now(): print('2015-3-25')把@log放到now()函数的定义处，相当于执行了语句：now = log(now)如果decorator本身需要传入参数，那就需要编写一个返回decorator的高阶函数def log(text): def decorator(func): def wrapper(*args, **kw): print('%s %s():' % (text, func.__name__)) return func(*args, **kw) return wrapper return decorator@log('execute')def now(): print('2015-3-25')Python内置的functools.wraps把原始函数的__name__等属性复制到wrapper()函数中import functoolsdef log(text): def decorator(func): @functools.wraps(func) def wrapper(*args, **kw): print('%s %s():' % (text, func.__name__)) return func(*args, **kw) return wrapper return decoratorexercise - 打印该函数的执行时间decoratordef metric(fn):\t@functools.wraps(fn)\tdef wrapper(*args, **kw):\t\tstart = time.time()\t\tr = fn(*args, **kw)\t\tprint('{:s} executed in {:s} ms'.format(fn.__name__, time.time() - start))\t\treturn r\treturn wrapper@metricdef fast(x, y): time.sleep(0.0012) return x + y偏函数简单总结functools.partial的作用就是，把一个函数的某些参数给固定住（也就是设置默认值），返回一个新的函数，调用这个新函数会更简单import functoolsint2 = functools.partial(int, base=2)模块在Python中，一个.py文件就称之为一个模块（Module）为了避免模块名冲突，Python又引入了按目录来组织模块的方法，称为包（Package）请注意，每一个包目录下面都会有一个__init__.py的文件，这个文件是必须存在的，否则，Python就把这个目录当成普通目录，而不是一个包。可以有多级目录，组成多级层次的包结构模块名不要和系统模块名冲突，最好先查看系统是否已存在该模块，检查方法是在Python交互环境执行import abc，若成功则说明系统存在此模块 自己创建模块时要注意命名，不能和Python自带的模块名称冲突。例如，系统自带了sys模块，自己的模块就不可命名为sys.py，否则将无法导入系统自带的sys模块理解一下这两行代码,假设这两行代码在一个hello模块中if __name__=='__main__': test()当我们在命令行运行hello模块文件时，Python解释器把一个特殊变量__name__置为__main__，而如果在其他地方导入该hello模块时，if判断将失败，因此，这种if测试可以让一个模块通过命令行运行时执行一些额外的代码，最常见的就是运行测试。公开的（public）函数和变量名可以被直接引用类似__xxx__这样的变量是特殊变量，可以被直接引用，但是有特殊用途非公开的（private）的函数或变量通过加一个前缀_来定义，类似_xxx和__xxx，他们不应该被直接引用，很好的代码封装和抽象外部不需要引用的函数全部定义成private，只有外部需要引用的函数才定义为public模块搜索路径，默认情况下，Python解释器会搜索当前目录、所有已安装的内置模块和第三方模块，搜索路径存放在sys模块的path变量中，如果我们要添加自己的搜索目录可以直接修改sys.path面向对象编程面向对象编程——Object Oriented Programming，简称OOP，是一种程序设计思想。OOP把对象作为程序的基本单元，一个对象包含了数据和操作数据的函数自定义的对象数据类型就是面向对象中的类（Class）的概念，类有属性和方法一个简单的Student类class Student(object): def __init__(self, name, score): self.name = name self.score = score def print_score(): print(\"{:s} {:d}\".format(self.name, self.score))# 创建一个instancebart = Student('Bart Simpson', 59)类（Class）和实例（Instance）class后面紧接着是类名，即Student，类名通常是大写开头的单词，紧接着是(object)，表示该类是从哪个类继承下来的，通常，如果没有合适的继承类，就使用object类，这是所有类最终都会继承的类。__init__方法，在创建实例的时候，需要强制绑定一些必须的属性。注意到__init__方法的第一个参数永远是self，表示创建的实例本身，因此，在__init__方法内部，就可以把各种属性绑定到self，因为self就指向创建的实例本身。类中所有方法的第一个参数一定是selfPython允许对实例变量绑定任何数据，也就是说，对于两个实例变量，虽然它们都是同一个类的不同实例，但拥有的变量名称都可能不同访问限制私有变量：如果要让内部属性不被外部访问，可以把属性的名称前加上两个下划线__，在Python中，实例的变量名如果以__开头，就变成了一个私有变量（private），只有内部可以访问，外部不能访问但是如果外部代码要获取name和score怎么办？可以给Student类增加get_name和get_score这样的方法如果要修改属性，可以给类增加set_方法，这样可以在修改属性时对参数做检查class Student(object): ... def get_name(self): return self.__name def get_score(self): return self.__score# 对传入参数做检查 def set_score(self, score): if 0 &lt;= score &lt;= 100: self.__score = score else: raise ValueError('bad score')以一个下划线开头的实例变量名，比如_name，这样的实例变量外部是可以访问的，但是，按照约定俗成的规定，当你看到这样的变量时，意思就是，“虽然我可以被访问，但是，请把我视为私有变量，不要随意访问”类也可以有属性，这个属性可以被类的所有实例访问，如果实例属性的名字和类属性的名字相同，实例属性会覆盖类属性继承和多态在OOP程序设计中，当我们定义一个class的时候，可以从某个现有的class继承，新的class称为子类（Subclass），而被继承的class称为基类、父类或超类（Base class、Super class）继承: 子类获得了父类的全部功能，在继承关系中，如果一个实例的数据类型是某个子类，那它的数据类型也可以被看做是父类。但是，反过来就不行多态: 当子类和父类都存在相同的方法时，子类的方法会覆盖父类的方法，在代码运行的时候，总是会调用子类的方法著名的“开闭”原则: 对扩展开放, 对修改封闭静态语言 vs 动态语言: Java是静态语言，Python是动态语言，动态语言的“鸭子类型”，它并不要求严格的继承体系，一个对象只要“看起来像鸭子，走起路来像鸭子”，那它就可以被看做是鸭子获取对象信息使用type()函数判断对象类型isinstance()函数判断class的类型如果要获得一个对象的所有属性和方法，可以使用dir()函数，它返回一个包含字符串的list配合getattr()、setattr()以及hasattr()，我们可以直接操作一个对象的状态面向对象高级编程为了达到限制的目的，Python允许在定义class的时候，定义一个特殊的__slots__变量，来限制该class实例能添加的属性class Student(object): __slots__ = ('name', 'age') # 用tuple定义允许绑定的属性名称使用__slots__要注意，__slots__定义的属性仅对当前类实例起作用，对继承的子类是不起作用的使用,除非在子类中也定义__slots__，这样，子类实例允许定义的属性就是自身的__slots__加上父类的__slots__使用@propertyPython内置的@property装饰器就是负责把一个方法变成属性调用的class Student(object): @property def score(self): return self._score @score.setter def score(self, value): if not isinstance(value, int): raise ValueError('score must be an integer!') if value &lt; 0 or value &gt; 100: raise ValueError('score must between 0 ~ 100!') self._score = value定义只读属性: 只定义getter方法，不定义setter方法就是一个只读属性多重继承很有用的性质：通过多重继承，一个子类就可以同时获得多个父类的所有功能定制类Python中有特殊用途的函数： __str__、__repr__()，打印出易于读的示例 __iter__, 返回一个可迭代的类 __getitem__，使类像list那样可以按照下标取出元素 __getattr__，动态返回一个属性，当调用不存在的属性时，Python解释器会试图调用__getattr__来尝试获得属性使用枚举类使用元类错误、调试和测试错误处理try...except...finally...的错误处理机制: try后面是测试执行语句，若没有报错，则跳过except，若报错，try中错误之后的语句不再执行，报一个exception。用这个方法的好处是即使报错了后面的程序仍然可以运行exception：Python的错误其实也是class，所有的错误类型都继承自BaseException，在使用exception时，父类错误会覆盖子类错误常见的错误类型和继承关系在这try: print('try') r = 10/0 print('result:' r)except ZeroDivisionError as e: print('except', e)也可以用Python内置的logging模块记录错误信息try…except可以捕获错误，raise可以抛出错误，例子def foo(s): n = int(s) if n==0: raise ValueError('invalid value: %s' % s) return 10/n调试用断言(assert)代替print来检查和调试，启动Python解释器时可以用-O参数来关闭assert。一个例子def foo(s): n = int(s) assert n!=0, \"n is zero\" return 10/0def main(): foo('0')第二种方法是用logging，比较复杂，以后需要的时候再考虑使用第三种是单步运行和断点：Python的调试器pdb可以让程序以单步方式运行，也可以用IDE单元测试“测试驱动开发”（TDD：Test-Driven Development）可以用Python自带的unittest模块编写单元测试，其实是编写一个测试类，一个例子import unittestfrom mydict import Dictclass TestDict(unittest.TestCase): def test_init(self): d = Dict(a=1, b='test') self.assertEqual(d.a, 1) self.assertEqual(d.b, 'test') self.assertTrue(isinstance(d, dict)) def test_key(self): d = Dict() d['key'] = 'value' self.assertEqual(d.key, 'value') def test_attr(self): d = Dict() d.key = 'value' self.assertTrue('key' in d) self.assertEqual(d['key'], 'value') def test_keyerror(self): d = Dict() with self.assertRaises(KeyError): value = d['empty'] def test_attrerror(self): d = Dict() with self.assertRaises(AttributeError): value = d.empty# 运行单元测试if __name__ == '__main__': unittest.main()可以在单元测试中编写两个特殊的setUp()和tearDown()方法。这两个方法会分别在每调用一个测试方法的前后分别被执行文档测试Python内置的“文档测试”（doctest）模块可以直接提取注释中的代码并执行测试IO编程操作文件和目录os模块, os.path模块可以让我们像在命令行中一样操作文件和目录常用函数：os.path.abspath('.')，os.path.join()，os.path.split()，os.path.splitext(), os.listdir(), os.mkdir()shutil模块可以看做是os模块的补充，比如copyfile()函数序列化我们把变量从内存中变成可存储或传输的过程称之为序列化，在Python中叫pickling，在其他语言中也被称之为serialization，marshalling，flattening等等，都是一个意思。Python提供了pickle模块来实现序列化: pickle.dump(variable, file)序列化一个变量并存入文件, pickle.load(variable, file)从一个file-like object中反序列化一个对象为变量把对象序列化为标准格式如JSON，因为JSON表示出来就是一个字符串，可以被所有语言读取，也可以方便地存储到磁盘或者通过网络传输Python内置的json模块提供了非常完善的Python对象到JSON格式的转换: json.dumps(), json.loads()如果要序列化一个类实例，需要把这个类转换为一个可序列化的字典，可以写一个函数转换也可以偷懒用print(json.dumps(s, default=lambda obj: obj.__dict__))进程和线程一个任务就是一个进程（Process）,进程内的“子任务”称为线程（Thread）multiprocessing模块是跨平台版本的多进程模块,multiprocessing模块提供了一个Process类来代表一个进程对象。一个例子from multiprocessing import Processimport osdef run_proc(name): print(\"Run child process %s (%s)\" % (name, os.getpid()))if __name__=='__main__': print(\"Parent process %s.\" % os.getpid()) p = Process(target=run_proc, args=('test')) print(\"Child process will start\") p.start() p.join() print(\"Child process end\")如果要启动大量的子进程，可以用进程池的方式批量创建子进程from multiprocessing import Poolimport os, time, randomdef long_time_task(name): print('Run task %s (%s)...' % (name, os.getpid())) start = time.time() time.sleep(random.random() * 3) end = time.time() print('Task %s runs %0.2f seconds.' % (name, (end - start)))if __name__=='__main__': print('Parent process %s.' % os.getpid()) p = Pool(4) for i in range(5): p.apply_async(long_time_task, args=(i,)) print('Waiting for all subprocesses done...') p.close() p.join() print('All subprocesses done.')子进程进程间通信可以通过Queue、Pipes等实现from multiprocessing import Process, Queueimport os, time, random# 写数据进程执行的代码:def write(q): print('Process to write: %s' % os.getpid()) for value in ['A', 'B', 'C']: print('Put %s to queue...' % value) q.put(value) time.sleep(random.random())# 读数据进程执行的代码:def read(q): print('Process to read: %s' % os.getpid()) while True: value = q.get(True) print('Get %s from queue.' % value)if __name__=='__main__': # 父进程创建Queue，并传给各个子进程： q = Queue() pw = Process(target=write, args=(q,)) pr = Process(target=read, args=(q,)) # 启动子进程pw，写入: pw.start() # 启动子进程pr，读取: pr.start() # 等待pw结束: pw.join() # pr进程里是死循环，无法等待其结束，只能强行终止: pr.terminate()多进程threading模块，启动一个线程就是把一个函数传入并创建Thread实例，然后调用start()开始执行,一个例子import time, threadingdef loop(): print('thread %s is running' % threading.current_thread().name) n = 0 while n &lt; 5: n += 1 print('thread %s &gt;&gt;&gt; %s' %(threading.current_thread().name, n)) time.sleep(1) print('thread %s ended.' % threading.current_thread().name)print('thread %s is running...' % threading.current_thread().name)t = threading.Thread(target=loop, name=\"LoopThread\")t.start()t.join()print('thread %s ended.' % threading.current_thread().name)Lock: 多线程编程，模型复杂，容易发生冲突，必须用锁加以隔离，同时，又要小心死锁的发生多线程在Python中只能交替执行，即使100个线程跑在100核CPU上，也只能用到1个核, 故Python中应当通过多进程实现多核任务ThreadLocal解决了参数在一个线程中各个函数之间互相传递的问题多进程模式最大的优点就是稳定性高,缺点是创建进程的代价大计算密集型 vs. IO密集型: 计算密集型任务同时进行的数量应当等于CPU的核心数，尽量用C语言编写Python中单线程的异步编程模型称为协程分布式进程很有意思的特性，但是现在暂时没什么兴趣去深究这个，稍微理解下原理就可以：有一个进程作为调度者，将任务分布到不同机器的其他进程中，他们之间通过网络通信正则表达式教程中的总结很简练，需要的话可以随时回来查阅在正则表达式中，如果直接给出字符，就是精确匹配。用\\d可以匹配一个数字，\\w可以匹配一个字母或数字，\\s匹配空格， .可以匹配任意字符要匹配变长的字符，在正则表达式中，用*表示任意个字符（包括0个），用+表示至少一个字符，用?表示0个或1个字符，用{n}表示n个字符，用{n,m}表示n-m个字符由于'-'是特殊字符，在正则表达式中，要用'\\'转义用[]表示范围, A|B可以匹配A或B, ^表示行的开头, $表示行的结束正则表达式还可以同来做字符串切分和分组正则匹配默认是贪婪匹配，加个?就可以让\\d+采用非贪婪匹配常用内建模块datetime模块collections模块是Python内建的一个集合模块，提供了许多有用的集合类 namedtuple: namedtuple是一个函数，它用来创建一个自定义的tuple对象，并且规定了tuple元素的个数，并可以用属性而不是索引来引用tuple的某个元素 deque: deque是为了高效实现插入和删除操作的双向列表，适合用于队列和栈 default: 在key不存在时返回一个默认值，默认值是调用函数返回的，而函数在创建defaultdict对象时传入，如dd = defaultdict(lambda: ‘N/A’)默认返回NA，或dd=default(list())返回list OrderedDict: OrderedDict的Key会按照插入的顺序排列，不是Key本身排序, 可以构建一个一个FIFO（先进先出）的dict，当容量超出限制时，先删除最早添加的Key - LastUpdatedOrderedDict ChainMap: ChainMap可以把一组dict串起来并组成一个逻辑上的dict, 应用程序传参时可以用ChainMap实现参数的优先级查找 Counter: Counter是一个简单的计数器，例如，统计字符出现的个数base64模块：Base64是一种任意二进制到文本字符串的编码方法，常用于在URL、Cookie、网页中传输少量二进制数据struct模块：用来解决bytes和其他二进制数据类型的转换hashlib模块提供了常见的摘要算法，如MD5，SHA1，摘要算法就是通过摘要函数f()对任意长度的数据data计算出固定长度的摘要digest，目的是为了发现原始数据是否被人篡改过，常用于验证用户登录itertools模块提供了非常有用的用于操作迭代对象的函数 chain(): 可以把一组迭代对象串联起来，形成一个更大的迭代器 groupby(): 把迭代器中相邻的重复元素挑出来放在一起,实际上挑选规则是通过函数完成的，只要作用于函数的两个元素返回的值相等，这两个元素就被认为是在一组的一个例子，迭代求pi的近似值def pi(N): # solution 1 return sum([4/x if (x-1)%4==0 else -4/x for x in range(1, 2*N-1, 2)]) # solution 2 odds = itertools.count(1, 2) od = itertools.takewhile(lambda x: x &lt; 2*N-1, odds) od = (4/x if (x-1)%4==0 else -4/x for x in od) sum(od)其他几个模块如contextlib, XML, urllib, HTMLParser等因为理解不深加上现在用的不多，暂时不记录常用第三方模块第三方模块大多都会在PyPI - the Python Package Index上注册，这些模块可用pip安装这部分的内容也是大概过一下就可以了，暂时不做深入学习网络编程网络通信就是两台计算机上的两个进程之间的通信电子邮件一封电子邮件的旅程： 发件人 -&gt; MUA -&gt; MTA -&gt; MTA -&gt; 若干个MTA -&gt; MDA &lt;- MUA &lt;- 收件人异步IO异步IO模型需要一个消息循环，在消息循环中，主线程不断地重复“读取消息-处理消息”这一过程对于大多数IO密集型的应用程序，使用异步IO将大大提升系统的多任务处理能力" }, { "title": "Write new post under Chirpy theme", "url": "/posts/writing-a-new-post/", "categories": "Tutorial", "tags": "Chirpy", "date": "2022-05-01 00:00:00 +0000", "snippet": "This post will guide you how to write a post on Chirpy theme. Even if you have previous experience with Jekyll, this article is worth reading, because many features require specific variables to be set.Naming and PathCreate a new file named YYYY-MM-DD-TITLE.EXTENSION and put it in the _posts of the root directory. Please note that the EXTENSION must be one of md and markdown. If you want to save time of creating files, please consider using the plugin Jekyll-Compose to accomplish this.Front MatterBasically, you need to fill the Front Matter as below at the top of the post:---title: TITLEdate: YYYY-MM-DD HH:MM:SS +/-TTTTcategories: [TOP_CATEGORIE, SUB_CATEGORIE]tags: [TAG] # TAG names should always be lowercase--- The posts’ layout has been set to post by default, so there is no need to add the variable layout in the Front Matter block.Timezone of DateIn order to accurately record the release date of a post, you should not only set up the timezone of _config.yml but also provide the post’s timezone in variable date of its Front Matter block. Format: +/-TTTT, e.g. +0800.Categories and TagsThe categories of each post are designed to contain up to two elements, and the number of elements in tags can be zero to infinity. For instance:---categories: [Animal, Insect]tags: [bee]---Author InformationThe author information of the post usually does not need to be filled in the Front Matter , they will be obtained from variables social.name and the first entry of social.links of the configuration file by default. But you can also override it as follows:Add author information in _data/authors.yml (If your website doesn’t have this file, don’t hesitate to create one.)&lt;author_id&gt;: name: &lt;full name&gt; twitter: &lt;twitter_of_author&gt; url: &lt;homepage_of_author&gt;{: file=\"_data/authors.yml\" }And then set up the custom author in the post’s YAML block:---author: &lt;author_id&gt;--- Another benefit of reading the author information from the file _data/authors.yml is that the page will have the meta tag twitter:creator, which enriches the Twitter Cards and is good for SEO.Table of ContentsBy default, the Table of Contents (TOC) is displayed on the right panel of the post. If you want to turn it off globally, go to _config.yml and set the value of variable toc to false. If you want to turn off TOC for a specific post, add the following to the post’s Front Matter:---toc: false---CommentsThe global switch of comments is defined by variable comments.active in the file _config.yml. After selecting a comment system for this variable, comments will be turned on for all posts.If you want to close the comment for a specific post, add the following to the Front Matter of the post:---comments: false---MathematicsFor website performance reasons, the mathematical feature won’t be loaded by default. But it can be enabled by:---math: true---MermaidMermaid is a great diagrams generation tool. To enable it on your post, add the following to the YAML block:---mermaid: true---Then you can use it like other markdown languages: surround the graph code with ```mermaid and ```.ImagesCaptionAdd italics to the next line of an image，then it will become the caption and appear at the bottom of the image:![img-description](/path/to/image)_Image Caption_SizeIn order to prevent the page content layout from shifting when the image is loaded, we should set the width and height for each image:![Desktop View](/assets/img/sample/mockup.png){: width=\"700\" height=\"400\" }Starting from Chirpy v5.0.0, height and width support abbreviations (height → h, width → w). The following example has the same effect as the above:![Desktop View](/assets/img/sample/mockup.png){: w=\"700\" h=\"400\" }PositionBy default, the image is centered, but you can specify the position by using one of the classes normal, left, and right. Once the position is specified, the image caption should not be added. Normal position Image will be left aligned in below sample: ![Desktop View](/assets/img/sample/mockup.png){: .normal } Float to the left ![Desktop View](/assets/img/sample/mockup.png){: .left } Float to the right ![Desktop View](/assets/img/sample/mockup.png){: .right } ShadowThe screenshots of the program window can be considered to show the shadow effect, and the shadow will be visible in the light mode:![Desktop View](/assets/img/sample/mockup.png){: .shadow }CDN URLIf you host the images on the CDN, you can save the time of repeatedly writing the CDN URL by assigning the variable img_cdn of _config.yml file:img_cdn: https://cdn.com{: file='_config.yml' .nolineno}Once img_cdn is assigned, the CDN URL will be added to the path of all images (images of site avatar and posts) starting with /.For instance, when using images:![The flower](/path/to/flower.png)The parsing result will automatically add the CDN prefix https://cdn.com before the image path:&lt;img src=\"https://cdn.com/path/to/flower.png\" alt=\"The flower\"&gt;Image PathWhen a post contains many images, it will be a time-consuming task to repeatedly define the path of the images. To solve this, we can define this path in the YAML block of the post:---img_path: /img/path/---And then, the image source of Markdown can write the file name directly:![The flower](flower.png)The output will be:&lt;img src=\"/img/path/flower.png\" alt=\"The flower\"&gt;Preview ImageIf you want to add an image to the top of the post contents, specify the attribute path, width, height, and alt for the image:---image: path: /path/to/image/file width: 1000 # in pixels height: 400 # in pixels alt: image alternative text---Except for alt, all other options are necessary, especially the width and height, which are related to user experience and web page loading performance. The above section “Size” also mentions this.Starting from Chirpy v5.0.0, the attributes height and width can be abbreviated: height → h, width → w. In addition, the img_path can also be passed to the preview image, that is, when it has been set, the attribute path only needs the image file name.Pinned PostsYou can pin one or more posts to the top of the home page, and the fixed posts are sorted in reverse order according to their release date. Enable by:---pin: true---PromptsThere are several types of prompts: tip, info, warning, and danger. They can be generated by adding the class prompt-{type} to the blockquote. For example, define a prompt of type info as follows:&gt; Example line for prompt.{: .prompt-info }SyntaxInline Code`inline code part`Filepath Hightlight`/path/to/a/file.extend`{: .filepath}Code BlockMarkdown symbols ``` can easily create a code block as follows:```This is a plaintext code snippet.```Specifying LanguageUsing ```{language} you will get a code block with syntax highlight:```yamlkey: value``` The Jekyll tag {% highlight %} is not compatible with this theme.Line NumberBy default, all languages except plaintext, console, and terminal will display line numbers. When you want to hide the line number of a code block, add the class nolineno to it:```shellecho 'No more line numbers!'```{: .nolineno }Specifying the FilenameYou may have noticed that the code language will be displayed at the top of the code block. If you want to replace it with the file name, you can add the attribute file to achieve this:```shell# content```{: file=\"path/to/file\" }Liquid CodesIf you want to display the Liquid snippet, surround the liquid code with {% raw %} and {% endraw %}:{% raw %}```liquid{% if product.title contains 'Pack' %} This product's title contains the word Pack.{% endif %}```{% endraw %}Or adding render_with_liquid: false (Requires Jekyll 4.0 or higher) to the post’s YAML block.Learn MoreFor more knowledge about Jekyll posts, visit the Jekyll Docs: Posts." }, { "title": "Linux", "url": "/posts/Linux-learning/", "categories": "Linux", "tags": "", "date": "2022-04-26 00:00:00 +0000", "snippet": "在Linux服务器上用Python开一个服务器python -m http.server --bind 10.20.57.27 10086将该服务器运行在tmux中便可以常驻后台运行服务器中的jupyter notebookjupyter notebook --no-browser --port 10087 --ip=10.20.57.27Zombie process处理僵尸进程要想杀死僵尸进程，一是杀掉僵尸进程本身，二是杀掉僵尸进程的父进程$ ps -A -o stat,ppid,pid,cmd | grep -e '^[Zz]' | awk '{print $2}' | xargs kill -9linux top进程状态D今天跑snakemake的流程的时候比前几次多用了8个核（总共用了24个），提交任务后发现所有的任务状态都变成了D，但是snakemake没有报错。上网找了状态D的形成原因和解决办法；D代表”uninterrunptable sleep”，一般是由于进程在长时间等待IO而没有获得响应导致的，处理方法一是可以让进程的IO得到满足，二只有reboot系统但是奇怪的是，我没有做任何操作，过了一会之后所有任务的状态又变成了R，可以完全正常跑下去了，不知道这次是不是由于一次性分配太多核的原因查看所有D状态的进程$ ps axwf -eo pid,stat | grep D" }, { "title": "How to build a blog by Jekyll and GitHub Actions", "url": "/posts/jekyll-site-in-github/", "categories": "Tutorial", "tags": "Jekyll", "date": "2022-04-24 00:00:00 +0000", "snippet": "This tutorial will teach you how to build a website based on Jekyll and GitHub Actions step by step in WindowsInstall prerequisitesInstall jekyll and bundler Download and install a Ruby+Devkit version from RubyInstaller Downloads. Use default options for installation Run the ridk install step on the last stage of the installation wizard (actually it’s automated, just click all the yes button) Open a new command prompt window from the start menu (windows + r, followed by cmd). Install Jekyll and Bundler using gem install jekyll bundler. Check if Jekyll has been installed properly: jekyll -vInstall GitJust follow the instructions of GitCreate a repository in GitHub Create a new repository in GitHub, its name should be USERNAME.github.io (for me, its sunjh22.github.io)Detailed procedures about this step can refer to the first few steps of Setting up a github pages site with jekyllCreate a jekyll site in local computer Open Git Bash Make a directory (such as ./MyBlog) and enter that directory Initialize a local Git repository (the name should be the same as previously created GitHub repository) (git init sunjh22.github.io), enter that repository Create a new jekyll site using jekyll new --skip-bundle, some basic files are produced, including Gemfile, config.yml etc. The default theme is minima, you can change the theme (for example, I used jekyll-theme-chirpy). Open Gemfile, change gem \"minima\", \"~&gt; 2.5\" to gem \"jekyll-theme-chirpy\", \"~&gt; 3.3\", \"&gt;= 3.3.0\", and change theme: minima to theme: jekyll-theme-chirpy in config.yml (Details can refer to this) From the command line, run bundle install Test site locally, if it works well, you should see a website in http://127.0.0.1:4000/ $ bundle add webrick $ bundle exec jekyll serve Deploy your website to GitHub Add a GitHub workflow file (e.g. .github/workflows/build-jekyll.yml) with the content as here, remember change master branch to your source code branch if it do not match (such as main). (if your default branch is master, you can change that to main by git checkout -b main) Add your repository on GitHub.com as a remote, replacing USER with the account that owns the repository and REPOSITORY with the name of the repository (e.g. mine is git remote add origin https://github.com/sunjh22/sunjh22.github.io.git) $ git remote add origin https://github.com/USER/REPOSITORY Add and commit your work $ git add . $ git commit -m 'Initial GitHub pages site with Jekyll' Push the repository to GitHub $ git push -u origin main On GitHub, the Build and Deploy to Github Pages workflow will build the site, after it was finished, a gh-pages branch will be created, navigate Settings, click Pages, then select gh-pages/root as publishing source. After a while, you can access your blog! (Mine is https://sunjh22.github.io/) Complete the content under Chirpy theme. Download Chirpy source code, unzip and copy directories _data, _includes, _javascript, _layouts, _plugins, _sass, _tabs and _assets to your website directory. Just revise the content and start writing your own post!" }, { "title": "Daily poem for my girlfriend", "url": "/posts/daily-poem/", "categories": "", "tags": "Poem", "date": "2022-01-01 00:00:00 +0000", "snippet": " 愿得一心人，白头不相离 - 卓文君 相思相见知何日？此时此夜难为情 - 李白 忆君心似西江水，日夜东流无歇时 - 鱼玄机 相思相望不相亲，天为谁春 - 纳兰容若 去年花里逢君别，今日花开又一年 - 韦应物 相寻梦里路，飞雨落花中 - 晏几道 白云千里万里，明月前溪后溪 - 刘长卿 海水梦悠悠，君愁我亦愁，南风知我意，吹梦到西洲 - 西洲曲 思君如流水，何有穷已时 - 徐干 春来秋去相思在，秋去春来信息违 - 鱼玄机 晓看天色暮看云，行也思君，坐也思君 - 唐寅 相逢情便深，恨不相逢早 - 施酒监 欲得周郎顾，时时误拂弦 - 李端 涉江采芙蓉，兰泽多芳草。采之欲遗谁？所思在远道 - 两汉佚名 千秋万古，为留待骚人，狂歌痛饮，来访雁丘处 - 元好问 雨打江南树。一夜花开无数。绿叶渐成阴，下有游人归路。与君相逢处。不道春将暮。把酒祝东风，且莫恁、匆匆去 - 王安石 月华星彩坐来收，岳色江声暗结愁。半夜灯前十年事，一时和雨到心头 - 杜荀鹤 何处花香入夜清？石林茅屋隔溪声。幽人月出每孤往，栖鸟山空时一鸣。草露不辞芒屦湿，松风偏与葛衣轻。临流欲写猗兰意，江北江南无限情 - 王守仁 一自移家入紫烟，深林住久遂忘年。山中莫道无供给，明月清风不用钱 - 王守仁 山石犹有理，山木犹有枝。人生非木石，别久宁无思。 - 王守仁 铿然舍瑟春风里，点也虽狂得我情 - 王守仁 四十馀年睡梦中，而今醒眼始朦胧。不知日已过亭午，起向高楼撞晓钟 - 王守仁 灵峭九万丈，参差生晓寒。仙人招我去，挥手青云端 - 王守仁 木末芙蓉花，山中发红萼。涧户寂无人，纷纷开且落。 - 王维 桃红复含宿雨，柳绿更带朝烟。花落家童未扫，莺啼山客犹眠。 - 王维 荆溪白石出，天寒红叶稀。山路元无雨，空翠湿人衣 - 王维 清川带长薄，车马去闲闲。流水如有意，暮禽相与还。荒城临古渡，落日满秋山。迢递嵩高下，归来且闭关 - 王维 独坐悲双鬓，空堂欲二更。雨中山果落，灯下草虫鸣。白发终难变，黄金不可成。欲知除老病，唯有学无生 - 王维 轻阴阁小雨，深院昼慵开。坐看苍苔色，欲上人衣来。 - 王维 惟有相思似春色，江南江北送君归。- 王维 寂寞掩柴扉，苍茫对落晖。鹤巢松树遍，人访荜门稀。绿竹含新粉，红莲落故衣。渡头烟火起，处处采菱归。 - 王维 萋萋春草秋绿，落落长松夏寒。牛羊自归村巷，童稚不识衣冠。 - 王维 移舟泊烟渚，日暮客愁新。野旷天低树，江清月近人。 - 孟浩然 潮落江平未有风，扁舟共济与君同。时时引领望天末，何处青山是越中。 - 孟浩然 弦弦掩抑声声思，似诉平生不得志。低眉信手续续弹，说尽心中无限事。 - 白居易 绿蚁新醅酒，红泥小火炉。晚来天欲雪，能饮一杯无？ - 白居易 我有所念人，隔在远远乡。我有所感事，结在深深肠。乡远去不得，无日不瞻望。肠深解不得，无夕不思量。 - 白居易 花非花，雾非雾。夜半来，天明去。来如春梦几多时？去似朝云无觅处。 - 白居易 南浦凄凄别，西风袅袅秋。一看肠一断，好去莫回头。 - 白居易 已讶衾枕冷，复见窗户明。夜深知雪重，时闻折竹声。 - 白居易 天平山上白云泉，云自无心水自闲。何必奔冲山下去，更添波浪向人间。 - 白居易 霜草苍苍虫切切，村南村北行人绝。独出门前望野田，月明荞麦花如雪。 - 白居易 弄石临溪坐，寻花绕寺行。时时闻鸟语，处处是泉声。 - 白居易 春风先发苑中梅，樱杏桃梨次第开。荠花榆荚深村里，亦道春风为我来。 - 白居易 晨起临风一惆怅，通川湓水断相闻。不知忆我因何事，昨夜三回梦见君。 - 白居易 凉冷三秋夜，安闲一老翁。卧迟灯灭后，睡美雨声中。灰宿温瓶火，香添暖被笼。晓晴寒未起，霜叶满阶红。 - 白居易 大都好物不坚牢，彩云易散琉璃脆。 - 白居易 丝纶阁下文书静，钟鼓楼中刻漏长。独坐黄昏谁是伴，紫薇花对紫微郎。 - 白居易 朝从紫禁归，暮出青门去。勿言城东陌，便是江南路。扬鞭簇车马，挥手辞亲故。我生本无乡，心安是归处。 - 白居易 小娃撑小艇，偷采白莲回。不解藏踪迹，浮萍一道开。 - 白居易 春未老，风细柳斜斜。试上超然台上看，半壕春水一城花。烟雨暗千家。寒食后，酒醒却咨嗟。休对故人思故国，且将新火试新茶。诗酒趁年华 - 苏轼 春宵一刻值千金，花有清香月有阴。歌管楼台声细细，秋千院落夜沉沉。 - 苏轼 一点浩然气，千里快哉风 - 苏轼 锦城丝管日纷纷，半入江风半入云。此曲只应天上有，人间能得几回闻。 - 杜甫 相逢情便深，恨不相逢早。识尽千千万万人，终不似、伊家好 - 施酒监 江碧鸟逾白，山青花欲燃。今春看又过，何日是归年？ - 杜甫 功盖三分国，名成八阵图。江流石不转，遗恨失吞吴。 - 杜甫 清江一曲抱村流，长夏江村事事幽。自去自来梁上燕，相亲相近水中鸥。 - 杜甫 王杨卢骆当时体，轻薄为文哂未休。尔曹身与名俱灭，不废江河万古流。 - 杜甫 云母屏风烛影深，长河渐落晓星沉。嫦娥应悔偷灵药，碧海青天夜夜心。 - 李商隐 昨夜星辰昨夜风，画楼西畔桂堂东。身无彩凤双飞翼，心有灵犀一点通。 - 李商隐 向晚意不适，驱车登古原。夕阳无限好，只是近黄昏。 - 李商隐 宣室求贤访逐臣，贾生才调更无伦。可怜夜半虚前席，不问苍生问鬼神。 - 李商隐 直道相思了无益，未妨惆怅是清狂。 - 李商隐 残阳西入崦，茅屋访孤僧。落叶人何在，寒云路几层。独敲初夜磬，闲倚一枝藤。世界微尘里，吾宁爱与憎。 - 李商隐 定定住天涯，依依向物华。寒梅最堪恨，常作去年花。 - 李商隐 寻芳不觉醉流霞，倚树沉眠日已斜。客散酒醒深夜后，更持红烛赏残花。 - 李商隐 世间荣落重逡巡，我独丘园坐四春。纵使有花兼有月，可堪无酒又无人。青袍似草年年定，白发如丝日日新。欲逐风波千万里，未知何路到龙津。 - 李商隐 滞雨长安夜，残灯独客愁。故乡云水地，归梦不宜秋。 - 李商隐 花明柳暗绕天愁，上尽重城更上楼。欲问孤鸿向何处？不知身世自悠悠。 - 李商隐 榴枝婀娜榴实繁，榴膜轻明榴子鲜。可羡瑶池碧桃树，碧桃红颊一千年。 - 李商隐 从来系日乏长绳，水去云回恨不胜。欲就麻姑买沧海，一杯春露冷如冰。 - 李商隐 地胜遗尘事，身闲念岁华。晚晴风过竹，深夜月当花。石乱知泉咽，苔荒任径斜。陶然恃琴酒，忘却在山家。 - 李商隐 无赖夭桃面，平明露井东。春风为开了，却拟笑春风。 - 李商隐 银烛秋光冷画屏，轻罗小扇扑流萤。天阶夜色凉如水，卧看牵牛织女星。 - 杜牧 青山隐隐水迢迢，秋尽江南草未凋。二十四桥明月夜，玉人何处教吹箫？ - 杜牧 娉娉袅袅十三余，豆蔻梢头二月初。春风十里扬州路，卷上珠帘总不如。 - 杜牧 长安回望绣成堆，山顶千门次第开。一骑红尘妃子笑，无人知是荔枝来。 - 杜牧 楼倚霜树外，镜天无一毫。南山与秋色，气势两相高。 - 杜牧 芦花深泽静垂纶，月夕烟朝几十春。自说孤舟寒水畔，不曾逢著独醒人。 - 杜牧 新年都未有芳华，二月初惊见草芽。白雪却嫌春色晚，故穿庭树作飞花。 - 韩愈 草树知春不久归，百般红紫斗芳菲。杨花榆荚无才思，惟解漫天作雪飞。 - 韩愈 结庐在人境，而无车马喧。问君何能尔？心远地自偏。采菊东篱下，悠然见南山。山气日夕佳，飞鸟相与还。此中有真意，欲辨已忘言。 - 陶渊明 人生无根蒂，飘如陌上尘。分散逐风转，此已非常身。落地为兄弟，何必骨肉亲！得欢当作乐，斗酒聚比邻。盛年不重来，一日难再晨。及时当勉励，岁月不待人。 - 陶渊明 忽逢桃花林，夹岸数百步，中无杂树，芳草鲜美，落英缤纷 - 陶渊明 归去来兮，田园将芜胡不归？既自以心为形役，奚惆怅而独悲？悟已往之不谏，知来者之可追。实迷途其未远，觉今是而昨非。舟遥遥以轻飏，风飘飘而吹衣。问征夫以前路，恨晨光之熹微 - 陶渊明 引壶觞以自酌，眄庭柯以怡颜。倚南窗以寄傲，审容膝之易安 - 陶渊明 富贵非吾愿，帝乡不可期。怀良辰以孤往，或植杖而耘耔。登东皋以舒啸，临清流而赋诗。聊乘化以归尽，乐夫天命复奚疑 - 陶渊明 江上往来人，但爱鲈鱼美。君看一叶舟，出没风波里。 - 范仲淹 一派青山景色幽，前人田地后人收。后人收得休欢喜，还有收人在后头。 - 范仲淹 饱去樱桃重，饥来柳絮轻。但知离此去，不用问前程。 - 范仲淹 小径小桃深，红光隐翠阴。是非不到耳，名利本无心。笋迸饶当户，云归半在林。何须听丝竹，山水有清音。 - 范仲淹 夜入翠烟啼，昼寻芳树飞。春山无限好，犹道不如归。 - 范仲淹 林下提壶招客醉，溪边杜宇劝人归。可怜白酒青山在，不醉不归多少非。 - 范仲淹 行歌春满路，坐歌春满园。花前人自乐，桃李岂须言。 - 范仲淹 萧洒桐庐郡，开轩即解颜。劳生一何幸，日日面青山。 - 范仲淹 片心高与月徘徊，岂为千锺下钓台。犹笑白云多事在，等闲为雨出山来。 - 范仲淹 春色人皆醉，秋光独不眠。君看明月下，何似落花前。 - 范仲淹 江南有美人，别后长相忆。何以慰相思，赠汝好颜色。 - 范仲淹 清言一以遥，默默江楼上。安得如白云，无心两相忘。 - 范仲淹 神仙一去几千年，自遣秦人不得还。春尽桃花无处觅，空馀流水到人间。 - 范仲淹 素心爱云水，此日东南行。笑解尘缨处，沧浪无限清。 - 范仲淹 至德本无名，宣尼一此凭。能将天下让，知有圣人生。南国奔方远，西山道始亨。英灵岂不在，千古碧江横。 - 范仲淹 君归一水遥，魂断木兰桡。赖有南轩竹，清风慰寂寥。 - 范仲淹 自古逢秋悲寂寥，我言秋日胜春朝。晴空一鹤排云上，便引诗情到碧霄。- 刘禹锡 杨柳青青江水平，闻郎江上唱歌声。东边日出西边雨，道是无晴却有晴。- 刘禹锡 山桃红花满上头，蜀江春水拍山流。花红易衰似郎意，水流无限似侬愁。- 刘禹锡 何处秋风至？萧萧送雁群。朝来入庭树，孤客最先闻。- 刘禹锡 葡萄美酒夜光杯，欲饮琵琶马上催。醉卧沙场君莫笑，古来征战几人回。- 王瀚 秦时明月汉时关，万里长征人未还，但使龙城飞将在，不教胡马度阴山。- 王昌龄" } ]
